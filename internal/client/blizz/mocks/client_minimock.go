package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/dog-sky/auctioneer/internal/client/blizz.Client -o ./mocks/client_minimock.go -n ClientMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_blizz "github.com/dog-sky/auctioneer/internal/client/blizz"
	"github.com/gojuno/minimock/v3"
)

// ClientMock implements blizz.Client
type ClientMock struct {
	t minimock.Tester

	funcBlizzAuthRoutine          func()
	inspectFuncBlizzAuthRoutine   func()
	afterBlizzAuthRoutineCounter  uint64
	beforeBlizzAuthRoutineCounter uint64
	BlizzAuthRoutineMock          mClientMockBlizzAuthRoutine

	funcGetAuctionData          func(realmID int, region string) (apa1 []*mm_blizz.AuctionsDetail, err error)
	inspectFuncGetAuctionData   func(realmID int, region string)
	afterGetAuctionDataCounter  uint64
	beforeGetAuctionDataCounter uint64
	GetAuctionDataMock          mClientMockGetAuctionData

	funcGetBlizzRealms          func() (err error)
	inspectFuncGetBlizzRealms   func()
	afterGetBlizzRealmsCounter  uint64
	beforeGetBlizzRealmsCounter uint64
	GetBlizzRealmsMock          mClientMockGetBlizzRealms

	funcGetItemMedia          func(itemID string) (ip1 *mm_blizz.ItemMedia, err error)
	inspectFuncGetItemMedia   func(itemID string)
	afterGetItemMediaCounter  uint64
	beforeGetItemMediaCounter uint64
	GetItemMediaMock          mClientMockGetItemMedia

	funcGetRealmID          func(s1 string) (i1 int)
	inspectFuncGetRealmID   func(s1 string)
	afterGetRealmIDCounter  uint64
	beforeGetRealmIDCounter uint64
	GetRealmIDMock          mClientMockGetRealmID

	funcMakeBlizzAuth          func() (err error)
	inspectFuncMakeBlizzAuth   func()
	afterMakeBlizzAuthCounter  uint64
	beforeMakeBlizzAuthCounter uint64
	MakeBlizzAuthMock          mClientMockMakeBlizzAuth

	funcSearchItem          func(itemName string, region string) (ip1 *mm_blizz.Item, err error)
	inspectFuncSearchItem   func(itemName string, region string)
	afterSearchItemCounter  uint64
	beforeSearchItemCounter uint64
	SearchItemMock          mClientMockSearchItem
}

// NewClientMock returns a mock for blizz.Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BlizzAuthRoutineMock = mClientMockBlizzAuthRoutine{mock: m}

	m.GetAuctionDataMock = mClientMockGetAuctionData{mock: m}
	m.GetAuctionDataMock.callArgs = []*ClientMockGetAuctionDataParams{}

	m.GetBlizzRealmsMock = mClientMockGetBlizzRealms{mock: m}

	m.GetItemMediaMock = mClientMockGetItemMedia{mock: m}
	m.GetItemMediaMock.callArgs = []*ClientMockGetItemMediaParams{}

	m.GetRealmIDMock = mClientMockGetRealmID{mock: m}
	m.GetRealmIDMock.callArgs = []*ClientMockGetRealmIDParams{}

	m.MakeBlizzAuthMock = mClientMockMakeBlizzAuth{mock: m}

	m.SearchItemMock = mClientMockSearchItem{mock: m}
	m.SearchItemMock.callArgs = []*ClientMockSearchItemParams{}

	return m
}

type mClientMockBlizzAuthRoutine struct {
	mock               *ClientMock
	defaultExpectation *ClientMockBlizzAuthRoutineExpectation
	expectations       []*ClientMockBlizzAuthRoutineExpectation
}

// ClientMockBlizzAuthRoutineExpectation specifies expectation struct of the Client.BlizzAuthRoutine
type ClientMockBlizzAuthRoutineExpectation struct {
	mock *ClientMock

	Counter uint64
}

// Expect sets up expected params for Client.BlizzAuthRoutine
func (mmBlizzAuthRoutine *mClientMockBlizzAuthRoutine) Expect() *mClientMockBlizzAuthRoutine {
	if mmBlizzAuthRoutine.mock.funcBlizzAuthRoutine != nil {
		mmBlizzAuthRoutine.mock.t.Fatalf("ClientMock.BlizzAuthRoutine mock is already set by Set")
	}

	if mmBlizzAuthRoutine.defaultExpectation == nil {
		mmBlizzAuthRoutine.defaultExpectation = &ClientMockBlizzAuthRoutineExpectation{}
	}

	return mmBlizzAuthRoutine
}

// Inspect accepts an inspector function that has same arguments as the Client.BlizzAuthRoutine
func (mmBlizzAuthRoutine *mClientMockBlizzAuthRoutine) Inspect(f func()) *mClientMockBlizzAuthRoutine {
	if mmBlizzAuthRoutine.mock.inspectFuncBlizzAuthRoutine != nil {
		mmBlizzAuthRoutine.mock.t.Fatalf("Inspect function is already set for ClientMock.BlizzAuthRoutine")
	}

	mmBlizzAuthRoutine.mock.inspectFuncBlizzAuthRoutine = f

	return mmBlizzAuthRoutine
}

// Return sets up results that will be returned by Client.BlizzAuthRoutine
func (mmBlizzAuthRoutine *mClientMockBlizzAuthRoutine) Return() *ClientMock {
	if mmBlizzAuthRoutine.mock.funcBlizzAuthRoutine != nil {
		mmBlizzAuthRoutine.mock.t.Fatalf("ClientMock.BlizzAuthRoutine mock is already set by Set")
	}

	if mmBlizzAuthRoutine.defaultExpectation == nil {
		mmBlizzAuthRoutine.defaultExpectation = &ClientMockBlizzAuthRoutineExpectation{mock: mmBlizzAuthRoutine.mock}
	}

	return mmBlizzAuthRoutine.mock
}

//Set uses given function f to mock the Client.BlizzAuthRoutine method
func (mmBlizzAuthRoutine *mClientMockBlizzAuthRoutine) Set(f func()) *ClientMock {
	if mmBlizzAuthRoutine.defaultExpectation != nil {
		mmBlizzAuthRoutine.mock.t.Fatalf("Default expectation is already set for the Client.BlizzAuthRoutine method")
	}

	if len(mmBlizzAuthRoutine.expectations) > 0 {
		mmBlizzAuthRoutine.mock.t.Fatalf("Some expectations are already set for the Client.BlizzAuthRoutine method")
	}

	mmBlizzAuthRoutine.mock.funcBlizzAuthRoutine = f
	return mmBlizzAuthRoutine.mock
}

// BlizzAuthRoutine implements blizz.Client
func (mmBlizzAuthRoutine *ClientMock) BlizzAuthRoutine() {
	mm_atomic.AddUint64(&mmBlizzAuthRoutine.beforeBlizzAuthRoutineCounter, 1)
	defer mm_atomic.AddUint64(&mmBlizzAuthRoutine.afterBlizzAuthRoutineCounter, 1)

	if mmBlizzAuthRoutine.inspectFuncBlizzAuthRoutine != nil {
		mmBlizzAuthRoutine.inspectFuncBlizzAuthRoutine()
	}

	if mmBlizzAuthRoutine.BlizzAuthRoutineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBlizzAuthRoutine.BlizzAuthRoutineMock.defaultExpectation.Counter, 1)

		return

	}
	if mmBlizzAuthRoutine.funcBlizzAuthRoutine != nil {
		mmBlizzAuthRoutine.funcBlizzAuthRoutine()
		return
	}
	mmBlizzAuthRoutine.t.Fatalf("Unexpected call to ClientMock.BlizzAuthRoutine.")

}

// BlizzAuthRoutineAfterCounter returns a count of finished ClientMock.BlizzAuthRoutine invocations
func (mmBlizzAuthRoutine *ClientMock) BlizzAuthRoutineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlizzAuthRoutine.afterBlizzAuthRoutineCounter)
}

// BlizzAuthRoutineBeforeCounter returns a count of ClientMock.BlizzAuthRoutine invocations
func (mmBlizzAuthRoutine *ClientMock) BlizzAuthRoutineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlizzAuthRoutine.beforeBlizzAuthRoutineCounter)
}

// MinimockBlizzAuthRoutineDone returns true if the count of the BlizzAuthRoutine invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockBlizzAuthRoutineDone() bool {
	for _, e := range m.BlizzAuthRoutineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlizzAuthRoutineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlizzAuthRoutineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlizzAuthRoutine != nil && mm_atomic.LoadUint64(&m.afterBlizzAuthRoutineCounter) < 1 {
		return false
	}
	return true
}

// MinimockBlizzAuthRoutineInspect logs each unmet expectation
func (m *ClientMock) MinimockBlizzAuthRoutineInspect() {
	for _, e := range m.BlizzAuthRoutineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.BlizzAuthRoutine")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlizzAuthRoutineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlizzAuthRoutineCounter) < 1 {
		m.t.Error("Expected call to ClientMock.BlizzAuthRoutine")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlizzAuthRoutine != nil && mm_atomic.LoadUint64(&m.afterBlizzAuthRoutineCounter) < 1 {
		m.t.Error("Expected call to ClientMock.BlizzAuthRoutine")
	}
}

type mClientMockGetAuctionData struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetAuctionDataExpectation
	expectations       []*ClientMockGetAuctionDataExpectation

	callArgs []*ClientMockGetAuctionDataParams
	mutex    sync.RWMutex
}

// ClientMockGetAuctionDataExpectation specifies expectation struct of the Client.GetAuctionData
type ClientMockGetAuctionDataExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetAuctionDataParams
	results *ClientMockGetAuctionDataResults
	Counter uint64
}

// ClientMockGetAuctionDataParams contains parameters of the Client.GetAuctionData
type ClientMockGetAuctionDataParams struct {
	realmID int
	region  string
}

// ClientMockGetAuctionDataResults contains results of the Client.GetAuctionData
type ClientMockGetAuctionDataResults struct {
	apa1 []*mm_blizz.AuctionsDetail
	err  error
}

// Expect sets up expected params for Client.GetAuctionData
func (mmGetAuctionData *mClientMockGetAuctionData) Expect(realmID int, region string) *mClientMockGetAuctionData {
	if mmGetAuctionData.mock.funcGetAuctionData != nil {
		mmGetAuctionData.mock.t.Fatalf("ClientMock.GetAuctionData mock is already set by Set")
	}

	if mmGetAuctionData.defaultExpectation == nil {
		mmGetAuctionData.defaultExpectation = &ClientMockGetAuctionDataExpectation{}
	}

	mmGetAuctionData.defaultExpectation.params = &ClientMockGetAuctionDataParams{realmID, region}
	for _, e := range mmGetAuctionData.expectations {
		if minimock.Equal(e.params, mmGetAuctionData.defaultExpectation.params) {
			mmGetAuctionData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAuctionData.defaultExpectation.params)
		}
	}

	return mmGetAuctionData
}

// Inspect accepts an inspector function that has same arguments as the Client.GetAuctionData
func (mmGetAuctionData *mClientMockGetAuctionData) Inspect(f func(realmID int, region string)) *mClientMockGetAuctionData {
	if mmGetAuctionData.mock.inspectFuncGetAuctionData != nil {
		mmGetAuctionData.mock.t.Fatalf("Inspect function is already set for ClientMock.GetAuctionData")
	}

	mmGetAuctionData.mock.inspectFuncGetAuctionData = f

	return mmGetAuctionData
}

// Return sets up results that will be returned by Client.GetAuctionData
func (mmGetAuctionData *mClientMockGetAuctionData) Return(apa1 []*mm_blizz.AuctionsDetail, err error) *ClientMock {
	if mmGetAuctionData.mock.funcGetAuctionData != nil {
		mmGetAuctionData.mock.t.Fatalf("ClientMock.GetAuctionData mock is already set by Set")
	}

	if mmGetAuctionData.defaultExpectation == nil {
		mmGetAuctionData.defaultExpectation = &ClientMockGetAuctionDataExpectation{mock: mmGetAuctionData.mock}
	}
	mmGetAuctionData.defaultExpectation.results = &ClientMockGetAuctionDataResults{apa1, err}
	return mmGetAuctionData.mock
}

//Set uses given function f to mock the Client.GetAuctionData method
func (mmGetAuctionData *mClientMockGetAuctionData) Set(f func(realmID int, region string) (apa1 []*mm_blizz.AuctionsDetail, err error)) *ClientMock {
	if mmGetAuctionData.defaultExpectation != nil {
		mmGetAuctionData.mock.t.Fatalf("Default expectation is already set for the Client.GetAuctionData method")
	}

	if len(mmGetAuctionData.expectations) > 0 {
		mmGetAuctionData.mock.t.Fatalf("Some expectations are already set for the Client.GetAuctionData method")
	}

	mmGetAuctionData.mock.funcGetAuctionData = f
	return mmGetAuctionData.mock
}

// When sets expectation for the Client.GetAuctionData which will trigger the result defined by the following
// Then helper
func (mmGetAuctionData *mClientMockGetAuctionData) When(realmID int, region string) *ClientMockGetAuctionDataExpectation {
	if mmGetAuctionData.mock.funcGetAuctionData != nil {
		mmGetAuctionData.mock.t.Fatalf("ClientMock.GetAuctionData mock is already set by Set")
	}

	expectation := &ClientMockGetAuctionDataExpectation{
		mock:   mmGetAuctionData.mock,
		params: &ClientMockGetAuctionDataParams{realmID, region},
	}
	mmGetAuctionData.expectations = append(mmGetAuctionData.expectations, expectation)
	return expectation
}

// Then sets up Client.GetAuctionData return parameters for the expectation previously defined by the When method
func (e *ClientMockGetAuctionDataExpectation) Then(apa1 []*mm_blizz.AuctionsDetail, err error) *ClientMock {
	e.results = &ClientMockGetAuctionDataResults{apa1, err}
	return e.mock
}

// GetAuctionData implements blizz.Client
func (mmGetAuctionData *ClientMock) GetAuctionData(realmID int, region string) (apa1 []*mm_blizz.AuctionsDetail, err error) {
	mm_atomic.AddUint64(&mmGetAuctionData.beforeGetAuctionDataCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAuctionData.afterGetAuctionDataCounter, 1)

	if mmGetAuctionData.inspectFuncGetAuctionData != nil {
		mmGetAuctionData.inspectFuncGetAuctionData(realmID, region)
	}

	mm_params := &ClientMockGetAuctionDataParams{realmID, region}

	// Record call args
	mmGetAuctionData.GetAuctionDataMock.mutex.Lock()
	mmGetAuctionData.GetAuctionDataMock.callArgs = append(mmGetAuctionData.GetAuctionDataMock.callArgs, mm_params)
	mmGetAuctionData.GetAuctionDataMock.mutex.Unlock()

	for _, e := range mmGetAuctionData.GetAuctionDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.apa1, e.results.err
		}
	}

	if mmGetAuctionData.GetAuctionDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAuctionData.GetAuctionDataMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAuctionData.GetAuctionDataMock.defaultExpectation.params
		mm_got := ClientMockGetAuctionDataParams{realmID, region}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAuctionData.t.Errorf("ClientMock.GetAuctionData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAuctionData.GetAuctionDataMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAuctionData.t.Fatal("No results are set for the ClientMock.GetAuctionData")
		}
		return (*mm_results).apa1, (*mm_results).err
	}
	if mmGetAuctionData.funcGetAuctionData != nil {
		return mmGetAuctionData.funcGetAuctionData(realmID, region)
	}
	mmGetAuctionData.t.Fatalf("Unexpected call to ClientMock.GetAuctionData. %v %v", realmID, region)
	return
}

// GetAuctionDataAfterCounter returns a count of finished ClientMock.GetAuctionData invocations
func (mmGetAuctionData *ClientMock) GetAuctionDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuctionData.afterGetAuctionDataCounter)
}

// GetAuctionDataBeforeCounter returns a count of ClientMock.GetAuctionData invocations
func (mmGetAuctionData *ClientMock) GetAuctionDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuctionData.beforeGetAuctionDataCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetAuctionData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAuctionData *mClientMockGetAuctionData) Calls() []*ClientMockGetAuctionDataParams {
	mmGetAuctionData.mutex.RLock()

	argCopy := make([]*ClientMockGetAuctionDataParams, len(mmGetAuctionData.callArgs))
	copy(argCopy, mmGetAuctionData.callArgs)

	mmGetAuctionData.mutex.RUnlock()

	return argCopy
}

// MinimockGetAuctionDataDone returns true if the count of the GetAuctionData invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetAuctionDataDone() bool {
	for _, e := range m.GetAuctionDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuctionDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAuctionDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuctionData != nil && mm_atomic.LoadUint64(&m.afterGetAuctionDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAuctionDataInspect logs each unmet expectation
func (m *ClientMock) MinimockGetAuctionDataInspect() {
	for _, e := range m.GetAuctionDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetAuctionData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuctionDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAuctionDataCounter) < 1 {
		if m.GetAuctionDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetAuctionData")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetAuctionData with params: %#v", *m.GetAuctionDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuctionData != nil && mm_atomic.LoadUint64(&m.afterGetAuctionDataCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetAuctionData")
	}
}

type mClientMockGetBlizzRealms struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetBlizzRealmsExpectation
	expectations       []*ClientMockGetBlizzRealmsExpectation
}

// ClientMockGetBlizzRealmsExpectation specifies expectation struct of the Client.GetBlizzRealms
type ClientMockGetBlizzRealmsExpectation struct {
	mock *ClientMock

	results *ClientMockGetBlizzRealmsResults
	Counter uint64
}

// ClientMockGetBlizzRealmsResults contains results of the Client.GetBlizzRealms
type ClientMockGetBlizzRealmsResults struct {
	err error
}

// Expect sets up expected params for Client.GetBlizzRealms
func (mmGetBlizzRealms *mClientMockGetBlizzRealms) Expect() *mClientMockGetBlizzRealms {
	if mmGetBlizzRealms.mock.funcGetBlizzRealms != nil {
		mmGetBlizzRealms.mock.t.Fatalf("ClientMock.GetBlizzRealms mock is already set by Set")
	}

	if mmGetBlizzRealms.defaultExpectation == nil {
		mmGetBlizzRealms.defaultExpectation = &ClientMockGetBlizzRealmsExpectation{}
	}

	return mmGetBlizzRealms
}

// Inspect accepts an inspector function that has same arguments as the Client.GetBlizzRealms
func (mmGetBlizzRealms *mClientMockGetBlizzRealms) Inspect(f func()) *mClientMockGetBlizzRealms {
	if mmGetBlizzRealms.mock.inspectFuncGetBlizzRealms != nil {
		mmGetBlizzRealms.mock.t.Fatalf("Inspect function is already set for ClientMock.GetBlizzRealms")
	}

	mmGetBlizzRealms.mock.inspectFuncGetBlizzRealms = f

	return mmGetBlizzRealms
}

// Return sets up results that will be returned by Client.GetBlizzRealms
func (mmGetBlizzRealms *mClientMockGetBlizzRealms) Return(err error) *ClientMock {
	if mmGetBlizzRealms.mock.funcGetBlizzRealms != nil {
		mmGetBlizzRealms.mock.t.Fatalf("ClientMock.GetBlizzRealms mock is already set by Set")
	}

	if mmGetBlizzRealms.defaultExpectation == nil {
		mmGetBlizzRealms.defaultExpectation = &ClientMockGetBlizzRealmsExpectation{mock: mmGetBlizzRealms.mock}
	}
	mmGetBlizzRealms.defaultExpectation.results = &ClientMockGetBlizzRealmsResults{err}
	return mmGetBlizzRealms.mock
}

//Set uses given function f to mock the Client.GetBlizzRealms method
func (mmGetBlizzRealms *mClientMockGetBlizzRealms) Set(f func() (err error)) *ClientMock {
	if mmGetBlizzRealms.defaultExpectation != nil {
		mmGetBlizzRealms.mock.t.Fatalf("Default expectation is already set for the Client.GetBlizzRealms method")
	}

	if len(mmGetBlizzRealms.expectations) > 0 {
		mmGetBlizzRealms.mock.t.Fatalf("Some expectations are already set for the Client.GetBlizzRealms method")
	}

	mmGetBlizzRealms.mock.funcGetBlizzRealms = f
	return mmGetBlizzRealms.mock
}

// GetBlizzRealms implements blizz.Client
func (mmGetBlizzRealms *ClientMock) GetBlizzRealms() (err error) {
	mm_atomic.AddUint64(&mmGetBlizzRealms.beforeGetBlizzRealmsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBlizzRealms.afterGetBlizzRealmsCounter, 1)

	if mmGetBlizzRealms.inspectFuncGetBlizzRealms != nil {
		mmGetBlizzRealms.inspectFuncGetBlizzRealms()
	}

	if mmGetBlizzRealms.GetBlizzRealmsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBlizzRealms.GetBlizzRealmsMock.defaultExpectation.Counter, 1)

		mm_results := mmGetBlizzRealms.GetBlizzRealmsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBlizzRealms.t.Fatal("No results are set for the ClientMock.GetBlizzRealms")
		}
		return (*mm_results).err
	}
	if mmGetBlizzRealms.funcGetBlizzRealms != nil {
		return mmGetBlizzRealms.funcGetBlizzRealms()
	}
	mmGetBlizzRealms.t.Fatalf("Unexpected call to ClientMock.GetBlizzRealms.")
	return
}

// GetBlizzRealmsAfterCounter returns a count of finished ClientMock.GetBlizzRealms invocations
func (mmGetBlizzRealms *ClientMock) GetBlizzRealmsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBlizzRealms.afterGetBlizzRealmsCounter)
}

// GetBlizzRealmsBeforeCounter returns a count of ClientMock.GetBlizzRealms invocations
func (mmGetBlizzRealms *ClientMock) GetBlizzRealmsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBlizzRealms.beforeGetBlizzRealmsCounter)
}

// MinimockGetBlizzRealmsDone returns true if the count of the GetBlizzRealms invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetBlizzRealmsDone() bool {
	for _, e := range m.GetBlizzRealmsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBlizzRealmsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBlizzRealmsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBlizzRealms != nil && mm_atomic.LoadUint64(&m.afterGetBlizzRealmsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetBlizzRealmsInspect logs each unmet expectation
func (m *ClientMock) MinimockGetBlizzRealmsInspect() {
	for _, e := range m.GetBlizzRealmsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.GetBlizzRealms")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBlizzRealmsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBlizzRealmsCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetBlizzRealms")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBlizzRealms != nil && mm_atomic.LoadUint64(&m.afterGetBlizzRealmsCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetBlizzRealms")
	}
}

type mClientMockGetItemMedia struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetItemMediaExpectation
	expectations       []*ClientMockGetItemMediaExpectation

	callArgs []*ClientMockGetItemMediaParams
	mutex    sync.RWMutex
}

// ClientMockGetItemMediaExpectation specifies expectation struct of the Client.GetItemMedia
type ClientMockGetItemMediaExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetItemMediaParams
	results *ClientMockGetItemMediaResults
	Counter uint64
}

// ClientMockGetItemMediaParams contains parameters of the Client.GetItemMedia
type ClientMockGetItemMediaParams struct {
	itemID string
}

// ClientMockGetItemMediaResults contains results of the Client.GetItemMedia
type ClientMockGetItemMediaResults struct {
	ip1 *mm_blizz.ItemMedia
	err error
}

// Expect sets up expected params for Client.GetItemMedia
func (mmGetItemMedia *mClientMockGetItemMedia) Expect(itemID string) *mClientMockGetItemMedia {
	if mmGetItemMedia.mock.funcGetItemMedia != nil {
		mmGetItemMedia.mock.t.Fatalf("ClientMock.GetItemMedia mock is already set by Set")
	}

	if mmGetItemMedia.defaultExpectation == nil {
		mmGetItemMedia.defaultExpectation = &ClientMockGetItemMediaExpectation{}
	}

	mmGetItemMedia.defaultExpectation.params = &ClientMockGetItemMediaParams{itemID}
	for _, e := range mmGetItemMedia.expectations {
		if minimock.Equal(e.params, mmGetItemMedia.defaultExpectation.params) {
			mmGetItemMedia.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemMedia.defaultExpectation.params)
		}
	}

	return mmGetItemMedia
}

// Inspect accepts an inspector function that has same arguments as the Client.GetItemMedia
func (mmGetItemMedia *mClientMockGetItemMedia) Inspect(f func(itemID string)) *mClientMockGetItemMedia {
	if mmGetItemMedia.mock.inspectFuncGetItemMedia != nil {
		mmGetItemMedia.mock.t.Fatalf("Inspect function is already set for ClientMock.GetItemMedia")
	}

	mmGetItemMedia.mock.inspectFuncGetItemMedia = f

	return mmGetItemMedia
}

// Return sets up results that will be returned by Client.GetItemMedia
func (mmGetItemMedia *mClientMockGetItemMedia) Return(ip1 *mm_blizz.ItemMedia, err error) *ClientMock {
	if mmGetItemMedia.mock.funcGetItemMedia != nil {
		mmGetItemMedia.mock.t.Fatalf("ClientMock.GetItemMedia mock is already set by Set")
	}

	if mmGetItemMedia.defaultExpectation == nil {
		mmGetItemMedia.defaultExpectation = &ClientMockGetItemMediaExpectation{mock: mmGetItemMedia.mock}
	}
	mmGetItemMedia.defaultExpectation.results = &ClientMockGetItemMediaResults{ip1, err}
	return mmGetItemMedia.mock
}

//Set uses given function f to mock the Client.GetItemMedia method
func (mmGetItemMedia *mClientMockGetItemMedia) Set(f func(itemID string) (ip1 *mm_blizz.ItemMedia, err error)) *ClientMock {
	if mmGetItemMedia.defaultExpectation != nil {
		mmGetItemMedia.mock.t.Fatalf("Default expectation is already set for the Client.GetItemMedia method")
	}

	if len(mmGetItemMedia.expectations) > 0 {
		mmGetItemMedia.mock.t.Fatalf("Some expectations are already set for the Client.GetItemMedia method")
	}

	mmGetItemMedia.mock.funcGetItemMedia = f
	return mmGetItemMedia.mock
}

// When sets expectation for the Client.GetItemMedia which will trigger the result defined by the following
// Then helper
func (mmGetItemMedia *mClientMockGetItemMedia) When(itemID string) *ClientMockGetItemMediaExpectation {
	if mmGetItemMedia.mock.funcGetItemMedia != nil {
		mmGetItemMedia.mock.t.Fatalf("ClientMock.GetItemMedia mock is already set by Set")
	}

	expectation := &ClientMockGetItemMediaExpectation{
		mock:   mmGetItemMedia.mock,
		params: &ClientMockGetItemMediaParams{itemID},
	}
	mmGetItemMedia.expectations = append(mmGetItemMedia.expectations, expectation)
	return expectation
}

// Then sets up Client.GetItemMedia return parameters for the expectation previously defined by the When method
func (e *ClientMockGetItemMediaExpectation) Then(ip1 *mm_blizz.ItemMedia, err error) *ClientMock {
	e.results = &ClientMockGetItemMediaResults{ip1, err}
	return e.mock
}

// GetItemMedia implements blizz.Client
func (mmGetItemMedia *ClientMock) GetItemMedia(itemID string) (ip1 *mm_blizz.ItemMedia, err error) {
	mm_atomic.AddUint64(&mmGetItemMedia.beforeGetItemMediaCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemMedia.afterGetItemMediaCounter, 1)

	if mmGetItemMedia.inspectFuncGetItemMedia != nil {
		mmGetItemMedia.inspectFuncGetItemMedia(itemID)
	}

	mm_params := &ClientMockGetItemMediaParams{itemID}

	// Record call args
	mmGetItemMedia.GetItemMediaMock.mutex.Lock()
	mmGetItemMedia.GetItemMediaMock.callArgs = append(mmGetItemMedia.GetItemMediaMock.callArgs, mm_params)
	mmGetItemMedia.GetItemMediaMock.mutex.Unlock()

	for _, e := range mmGetItemMedia.GetItemMediaMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmGetItemMedia.GetItemMediaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemMedia.GetItemMediaMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemMedia.GetItemMediaMock.defaultExpectation.params
		mm_got := ClientMockGetItemMediaParams{itemID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemMedia.t.Errorf("ClientMock.GetItemMedia got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemMedia.GetItemMediaMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemMedia.t.Fatal("No results are set for the ClientMock.GetItemMedia")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmGetItemMedia.funcGetItemMedia != nil {
		return mmGetItemMedia.funcGetItemMedia(itemID)
	}
	mmGetItemMedia.t.Fatalf("Unexpected call to ClientMock.GetItemMedia. %v", itemID)
	return
}

// GetItemMediaAfterCounter returns a count of finished ClientMock.GetItemMedia invocations
func (mmGetItemMedia *ClientMock) GetItemMediaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemMedia.afterGetItemMediaCounter)
}

// GetItemMediaBeforeCounter returns a count of ClientMock.GetItemMedia invocations
func (mmGetItemMedia *ClientMock) GetItemMediaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemMedia.beforeGetItemMediaCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetItemMedia.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemMedia *mClientMockGetItemMedia) Calls() []*ClientMockGetItemMediaParams {
	mmGetItemMedia.mutex.RLock()

	argCopy := make([]*ClientMockGetItemMediaParams, len(mmGetItemMedia.callArgs))
	copy(argCopy, mmGetItemMedia.callArgs)

	mmGetItemMedia.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemMediaDone returns true if the count of the GetItemMedia invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetItemMediaDone() bool {
	for _, e := range m.GetItemMediaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemMediaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemMediaCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemMedia != nil && mm_atomic.LoadUint64(&m.afterGetItemMediaCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetItemMediaInspect logs each unmet expectation
func (m *ClientMock) MinimockGetItemMediaInspect() {
	for _, e := range m.GetItemMediaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetItemMedia with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemMediaMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemMediaCounter) < 1 {
		if m.GetItemMediaMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetItemMedia")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetItemMedia with params: %#v", *m.GetItemMediaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemMedia != nil && mm_atomic.LoadUint64(&m.afterGetItemMediaCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetItemMedia")
	}
}

type mClientMockGetRealmID struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetRealmIDExpectation
	expectations       []*ClientMockGetRealmIDExpectation

	callArgs []*ClientMockGetRealmIDParams
	mutex    sync.RWMutex
}

// ClientMockGetRealmIDExpectation specifies expectation struct of the Client.GetRealmID
type ClientMockGetRealmIDExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetRealmIDParams
	results *ClientMockGetRealmIDResults
	Counter uint64
}

// ClientMockGetRealmIDParams contains parameters of the Client.GetRealmID
type ClientMockGetRealmIDParams struct {
	s1 string
}

// ClientMockGetRealmIDResults contains results of the Client.GetRealmID
type ClientMockGetRealmIDResults struct {
	i1 int
}

// Expect sets up expected params for Client.GetRealmID
func (mmGetRealmID *mClientMockGetRealmID) Expect(s1 string) *mClientMockGetRealmID {
	if mmGetRealmID.mock.funcGetRealmID != nil {
		mmGetRealmID.mock.t.Fatalf("ClientMock.GetRealmID mock is already set by Set")
	}

	if mmGetRealmID.defaultExpectation == nil {
		mmGetRealmID.defaultExpectation = &ClientMockGetRealmIDExpectation{}
	}

	mmGetRealmID.defaultExpectation.params = &ClientMockGetRealmIDParams{s1}
	for _, e := range mmGetRealmID.expectations {
		if minimock.Equal(e.params, mmGetRealmID.defaultExpectation.params) {
			mmGetRealmID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRealmID.defaultExpectation.params)
		}
	}

	return mmGetRealmID
}

// Inspect accepts an inspector function that has same arguments as the Client.GetRealmID
func (mmGetRealmID *mClientMockGetRealmID) Inspect(f func(s1 string)) *mClientMockGetRealmID {
	if mmGetRealmID.mock.inspectFuncGetRealmID != nil {
		mmGetRealmID.mock.t.Fatalf("Inspect function is already set for ClientMock.GetRealmID")
	}

	mmGetRealmID.mock.inspectFuncGetRealmID = f

	return mmGetRealmID
}

// Return sets up results that will be returned by Client.GetRealmID
func (mmGetRealmID *mClientMockGetRealmID) Return(i1 int) *ClientMock {
	if mmGetRealmID.mock.funcGetRealmID != nil {
		mmGetRealmID.mock.t.Fatalf("ClientMock.GetRealmID mock is already set by Set")
	}

	if mmGetRealmID.defaultExpectation == nil {
		mmGetRealmID.defaultExpectation = &ClientMockGetRealmIDExpectation{mock: mmGetRealmID.mock}
	}
	mmGetRealmID.defaultExpectation.results = &ClientMockGetRealmIDResults{i1}
	return mmGetRealmID.mock
}

//Set uses given function f to mock the Client.GetRealmID method
func (mmGetRealmID *mClientMockGetRealmID) Set(f func(s1 string) (i1 int)) *ClientMock {
	if mmGetRealmID.defaultExpectation != nil {
		mmGetRealmID.mock.t.Fatalf("Default expectation is already set for the Client.GetRealmID method")
	}

	if len(mmGetRealmID.expectations) > 0 {
		mmGetRealmID.mock.t.Fatalf("Some expectations are already set for the Client.GetRealmID method")
	}

	mmGetRealmID.mock.funcGetRealmID = f
	return mmGetRealmID.mock
}

// When sets expectation for the Client.GetRealmID which will trigger the result defined by the following
// Then helper
func (mmGetRealmID *mClientMockGetRealmID) When(s1 string) *ClientMockGetRealmIDExpectation {
	if mmGetRealmID.mock.funcGetRealmID != nil {
		mmGetRealmID.mock.t.Fatalf("ClientMock.GetRealmID mock is already set by Set")
	}

	expectation := &ClientMockGetRealmIDExpectation{
		mock:   mmGetRealmID.mock,
		params: &ClientMockGetRealmIDParams{s1},
	}
	mmGetRealmID.expectations = append(mmGetRealmID.expectations, expectation)
	return expectation
}

// Then sets up Client.GetRealmID return parameters for the expectation previously defined by the When method
func (e *ClientMockGetRealmIDExpectation) Then(i1 int) *ClientMock {
	e.results = &ClientMockGetRealmIDResults{i1}
	return e.mock
}

// GetRealmID implements blizz.Client
func (mmGetRealmID *ClientMock) GetRealmID(s1 string) (i1 int) {
	mm_atomic.AddUint64(&mmGetRealmID.beforeGetRealmIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRealmID.afterGetRealmIDCounter, 1)

	if mmGetRealmID.inspectFuncGetRealmID != nil {
		mmGetRealmID.inspectFuncGetRealmID(s1)
	}

	mm_params := &ClientMockGetRealmIDParams{s1}

	// Record call args
	mmGetRealmID.GetRealmIDMock.mutex.Lock()
	mmGetRealmID.GetRealmIDMock.callArgs = append(mmGetRealmID.GetRealmIDMock.callArgs, mm_params)
	mmGetRealmID.GetRealmIDMock.mutex.Unlock()

	for _, e := range mmGetRealmID.GetRealmIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmGetRealmID.GetRealmIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRealmID.GetRealmIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRealmID.GetRealmIDMock.defaultExpectation.params
		mm_got := ClientMockGetRealmIDParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRealmID.t.Errorf("ClientMock.GetRealmID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRealmID.GetRealmIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRealmID.t.Fatal("No results are set for the ClientMock.GetRealmID")
		}
		return (*mm_results).i1
	}
	if mmGetRealmID.funcGetRealmID != nil {
		return mmGetRealmID.funcGetRealmID(s1)
	}
	mmGetRealmID.t.Fatalf("Unexpected call to ClientMock.GetRealmID. %v", s1)
	return
}

// GetRealmIDAfterCounter returns a count of finished ClientMock.GetRealmID invocations
func (mmGetRealmID *ClientMock) GetRealmIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRealmID.afterGetRealmIDCounter)
}

// GetRealmIDBeforeCounter returns a count of ClientMock.GetRealmID invocations
func (mmGetRealmID *ClientMock) GetRealmIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRealmID.beforeGetRealmIDCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetRealmID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRealmID *mClientMockGetRealmID) Calls() []*ClientMockGetRealmIDParams {
	mmGetRealmID.mutex.RLock()

	argCopy := make([]*ClientMockGetRealmIDParams, len(mmGetRealmID.callArgs))
	copy(argCopy, mmGetRealmID.callArgs)

	mmGetRealmID.mutex.RUnlock()

	return argCopy
}

// MinimockGetRealmIDDone returns true if the count of the GetRealmID invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetRealmIDDone() bool {
	for _, e := range m.GetRealmIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRealmIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRealmIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRealmID != nil && mm_atomic.LoadUint64(&m.afterGetRealmIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRealmIDInspect logs each unmet expectation
func (m *ClientMock) MinimockGetRealmIDInspect() {
	for _, e := range m.GetRealmIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetRealmID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRealmIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRealmIDCounter) < 1 {
		if m.GetRealmIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetRealmID")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetRealmID with params: %#v", *m.GetRealmIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRealmID != nil && mm_atomic.LoadUint64(&m.afterGetRealmIDCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetRealmID")
	}
}

type mClientMockMakeBlizzAuth struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMakeBlizzAuthExpectation
	expectations       []*ClientMockMakeBlizzAuthExpectation
}

// ClientMockMakeBlizzAuthExpectation specifies expectation struct of the Client.MakeBlizzAuth
type ClientMockMakeBlizzAuthExpectation struct {
	mock *ClientMock

	results *ClientMockMakeBlizzAuthResults
	Counter uint64
}

// ClientMockMakeBlizzAuthResults contains results of the Client.MakeBlizzAuth
type ClientMockMakeBlizzAuthResults struct {
	err error
}

// Expect sets up expected params for Client.MakeBlizzAuth
func (mmMakeBlizzAuth *mClientMockMakeBlizzAuth) Expect() *mClientMockMakeBlizzAuth {
	if mmMakeBlizzAuth.mock.funcMakeBlizzAuth != nil {
		mmMakeBlizzAuth.mock.t.Fatalf("ClientMock.MakeBlizzAuth mock is already set by Set")
	}

	if mmMakeBlizzAuth.defaultExpectation == nil {
		mmMakeBlizzAuth.defaultExpectation = &ClientMockMakeBlizzAuthExpectation{}
	}

	return mmMakeBlizzAuth
}

// Inspect accepts an inspector function that has same arguments as the Client.MakeBlizzAuth
func (mmMakeBlizzAuth *mClientMockMakeBlizzAuth) Inspect(f func()) *mClientMockMakeBlizzAuth {
	if mmMakeBlizzAuth.mock.inspectFuncMakeBlizzAuth != nil {
		mmMakeBlizzAuth.mock.t.Fatalf("Inspect function is already set for ClientMock.MakeBlizzAuth")
	}

	mmMakeBlizzAuth.mock.inspectFuncMakeBlizzAuth = f

	return mmMakeBlizzAuth
}

// Return sets up results that will be returned by Client.MakeBlizzAuth
func (mmMakeBlizzAuth *mClientMockMakeBlizzAuth) Return(err error) *ClientMock {
	if mmMakeBlizzAuth.mock.funcMakeBlizzAuth != nil {
		mmMakeBlizzAuth.mock.t.Fatalf("ClientMock.MakeBlizzAuth mock is already set by Set")
	}

	if mmMakeBlizzAuth.defaultExpectation == nil {
		mmMakeBlizzAuth.defaultExpectation = &ClientMockMakeBlizzAuthExpectation{mock: mmMakeBlizzAuth.mock}
	}
	mmMakeBlizzAuth.defaultExpectation.results = &ClientMockMakeBlizzAuthResults{err}
	return mmMakeBlizzAuth.mock
}

//Set uses given function f to mock the Client.MakeBlizzAuth method
func (mmMakeBlizzAuth *mClientMockMakeBlizzAuth) Set(f func() (err error)) *ClientMock {
	if mmMakeBlizzAuth.defaultExpectation != nil {
		mmMakeBlizzAuth.mock.t.Fatalf("Default expectation is already set for the Client.MakeBlizzAuth method")
	}

	if len(mmMakeBlizzAuth.expectations) > 0 {
		mmMakeBlizzAuth.mock.t.Fatalf("Some expectations are already set for the Client.MakeBlizzAuth method")
	}

	mmMakeBlizzAuth.mock.funcMakeBlizzAuth = f
	return mmMakeBlizzAuth.mock
}

// MakeBlizzAuth implements blizz.Client
func (mmMakeBlizzAuth *ClientMock) MakeBlizzAuth() (err error) {
	mm_atomic.AddUint64(&mmMakeBlizzAuth.beforeMakeBlizzAuthCounter, 1)
	defer mm_atomic.AddUint64(&mmMakeBlizzAuth.afterMakeBlizzAuthCounter, 1)

	if mmMakeBlizzAuth.inspectFuncMakeBlizzAuth != nil {
		mmMakeBlizzAuth.inspectFuncMakeBlizzAuth()
	}

	if mmMakeBlizzAuth.MakeBlizzAuthMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMakeBlizzAuth.MakeBlizzAuthMock.defaultExpectation.Counter, 1)

		mm_results := mmMakeBlizzAuth.MakeBlizzAuthMock.defaultExpectation.results
		if mm_results == nil {
			mmMakeBlizzAuth.t.Fatal("No results are set for the ClientMock.MakeBlizzAuth")
		}
		return (*mm_results).err
	}
	if mmMakeBlizzAuth.funcMakeBlizzAuth != nil {
		return mmMakeBlizzAuth.funcMakeBlizzAuth()
	}
	mmMakeBlizzAuth.t.Fatalf("Unexpected call to ClientMock.MakeBlizzAuth.")
	return
}

// MakeBlizzAuthAfterCounter returns a count of finished ClientMock.MakeBlizzAuth invocations
func (mmMakeBlizzAuth *ClientMock) MakeBlizzAuthAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeBlizzAuth.afterMakeBlizzAuthCounter)
}

// MakeBlizzAuthBeforeCounter returns a count of ClientMock.MakeBlizzAuth invocations
func (mmMakeBlizzAuth *ClientMock) MakeBlizzAuthBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeBlizzAuth.beforeMakeBlizzAuthCounter)
}

// MinimockMakeBlizzAuthDone returns true if the count of the MakeBlizzAuth invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMakeBlizzAuthDone() bool {
	for _, e := range m.MakeBlizzAuthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MakeBlizzAuthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMakeBlizzAuthCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMakeBlizzAuth != nil && mm_atomic.LoadUint64(&m.afterMakeBlizzAuthCounter) < 1 {
		return false
	}
	return true
}

// MinimockMakeBlizzAuthInspect logs each unmet expectation
func (m *ClientMock) MinimockMakeBlizzAuthInspect() {
	for _, e := range m.MakeBlizzAuthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.MakeBlizzAuth")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MakeBlizzAuthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMakeBlizzAuthCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MakeBlizzAuth")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMakeBlizzAuth != nil && mm_atomic.LoadUint64(&m.afterMakeBlizzAuthCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MakeBlizzAuth")
	}
}

type mClientMockSearchItem struct {
	mock               *ClientMock
	defaultExpectation *ClientMockSearchItemExpectation
	expectations       []*ClientMockSearchItemExpectation

	callArgs []*ClientMockSearchItemParams
	mutex    sync.RWMutex
}

// ClientMockSearchItemExpectation specifies expectation struct of the Client.SearchItem
type ClientMockSearchItemExpectation struct {
	mock    *ClientMock
	params  *ClientMockSearchItemParams
	results *ClientMockSearchItemResults
	Counter uint64
}

// ClientMockSearchItemParams contains parameters of the Client.SearchItem
type ClientMockSearchItemParams struct {
	itemName string
	region   string
}

// ClientMockSearchItemResults contains results of the Client.SearchItem
type ClientMockSearchItemResults struct {
	ip1 *mm_blizz.Item
	err error
}

// Expect sets up expected params for Client.SearchItem
func (mmSearchItem *mClientMockSearchItem) Expect(itemName string, region string) *mClientMockSearchItem {
	if mmSearchItem.mock.funcSearchItem != nil {
		mmSearchItem.mock.t.Fatalf("ClientMock.SearchItem mock is already set by Set")
	}

	if mmSearchItem.defaultExpectation == nil {
		mmSearchItem.defaultExpectation = &ClientMockSearchItemExpectation{}
	}

	mmSearchItem.defaultExpectation.params = &ClientMockSearchItemParams{itemName, region}
	for _, e := range mmSearchItem.expectations {
		if minimock.Equal(e.params, mmSearchItem.defaultExpectation.params) {
			mmSearchItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchItem.defaultExpectation.params)
		}
	}

	return mmSearchItem
}

// Inspect accepts an inspector function that has same arguments as the Client.SearchItem
func (mmSearchItem *mClientMockSearchItem) Inspect(f func(itemName string, region string)) *mClientMockSearchItem {
	if mmSearchItem.mock.inspectFuncSearchItem != nil {
		mmSearchItem.mock.t.Fatalf("Inspect function is already set for ClientMock.SearchItem")
	}

	mmSearchItem.mock.inspectFuncSearchItem = f

	return mmSearchItem
}

// Return sets up results that will be returned by Client.SearchItem
func (mmSearchItem *mClientMockSearchItem) Return(ip1 *mm_blizz.Item, err error) *ClientMock {
	if mmSearchItem.mock.funcSearchItem != nil {
		mmSearchItem.mock.t.Fatalf("ClientMock.SearchItem mock is already set by Set")
	}

	if mmSearchItem.defaultExpectation == nil {
		mmSearchItem.defaultExpectation = &ClientMockSearchItemExpectation{mock: mmSearchItem.mock}
	}
	mmSearchItem.defaultExpectation.results = &ClientMockSearchItemResults{ip1, err}
	return mmSearchItem.mock
}

//Set uses given function f to mock the Client.SearchItem method
func (mmSearchItem *mClientMockSearchItem) Set(f func(itemName string, region string) (ip1 *mm_blizz.Item, err error)) *ClientMock {
	if mmSearchItem.defaultExpectation != nil {
		mmSearchItem.mock.t.Fatalf("Default expectation is already set for the Client.SearchItem method")
	}

	if len(mmSearchItem.expectations) > 0 {
		mmSearchItem.mock.t.Fatalf("Some expectations are already set for the Client.SearchItem method")
	}

	mmSearchItem.mock.funcSearchItem = f
	return mmSearchItem.mock
}

// When sets expectation for the Client.SearchItem which will trigger the result defined by the following
// Then helper
func (mmSearchItem *mClientMockSearchItem) When(itemName string, region string) *ClientMockSearchItemExpectation {
	if mmSearchItem.mock.funcSearchItem != nil {
		mmSearchItem.mock.t.Fatalf("ClientMock.SearchItem mock is already set by Set")
	}

	expectation := &ClientMockSearchItemExpectation{
		mock:   mmSearchItem.mock,
		params: &ClientMockSearchItemParams{itemName, region},
	}
	mmSearchItem.expectations = append(mmSearchItem.expectations, expectation)
	return expectation
}

// Then sets up Client.SearchItem return parameters for the expectation previously defined by the When method
func (e *ClientMockSearchItemExpectation) Then(ip1 *mm_blizz.Item, err error) *ClientMock {
	e.results = &ClientMockSearchItemResults{ip1, err}
	return e.mock
}

// SearchItem implements blizz.Client
func (mmSearchItem *ClientMock) SearchItem(itemName string, region string) (ip1 *mm_blizz.Item, err error) {
	mm_atomic.AddUint64(&mmSearchItem.beforeSearchItemCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchItem.afterSearchItemCounter, 1)

	if mmSearchItem.inspectFuncSearchItem != nil {
		mmSearchItem.inspectFuncSearchItem(itemName, region)
	}

	mm_params := &ClientMockSearchItemParams{itemName, region}

	// Record call args
	mmSearchItem.SearchItemMock.mutex.Lock()
	mmSearchItem.SearchItemMock.callArgs = append(mmSearchItem.SearchItemMock.callArgs, mm_params)
	mmSearchItem.SearchItemMock.mutex.Unlock()

	for _, e := range mmSearchItem.SearchItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmSearchItem.SearchItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchItem.SearchItemMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchItem.SearchItemMock.defaultExpectation.params
		mm_got := ClientMockSearchItemParams{itemName, region}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchItem.t.Errorf("ClientMock.SearchItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchItem.SearchItemMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchItem.t.Fatal("No results are set for the ClientMock.SearchItem")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmSearchItem.funcSearchItem != nil {
		return mmSearchItem.funcSearchItem(itemName, region)
	}
	mmSearchItem.t.Fatalf("Unexpected call to ClientMock.SearchItem. %v %v", itemName, region)
	return
}

// SearchItemAfterCounter returns a count of finished ClientMock.SearchItem invocations
func (mmSearchItem *ClientMock) SearchItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchItem.afterSearchItemCounter)
}

// SearchItemBeforeCounter returns a count of ClientMock.SearchItem invocations
func (mmSearchItem *ClientMock) SearchItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchItem.beforeSearchItemCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.SearchItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchItem *mClientMockSearchItem) Calls() []*ClientMockSearchItemParams {
	mmSearchItem.mutex.RLock()

	argCopy := make([]*ClientMockSearchItemParams, len(mmSearchItem.callArgs))
	copy(argCopy, mmSearchItem.callArgs)

	mmSearchItem.mutex.RUnlock()

	return argCopy
}

// MinimockSearchItemDone returns true if the count of the SearchItem invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockSearchItemDone() bool {
	for _, e := range m.SearchItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SearchItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSearchItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchItem != nil && mm_atomic.LoadUint64(&m.afterSearchItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockSearchItemInspect logs each unmet expectation
func (m *ClientMock) MinimockSearchItemInspect() {
	for _, e := range m.SearchItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.SearchItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SearchItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSearchItemCounter) < 1 {
		if m.SearchItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.SearchItem")
		} else {
			m.t.Errorf("Expected call to ClientMock.SearchItem with params: %#v", *m.SearchItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchItem != nil && mm_atomic.LoadUint64(&m.afterSearchItemCounter) < 1 {
		m.t.Error("Expected call to ClientMock.SearchItem")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBlizzAuthRoutineInspect()

		m.MinimockGetAuctionDataInspect()

		m.MinimockGetBlizzRealmsInspect()

		m.MinimockGetItemMediaInspect()

		m.MinimockGetRealmIDInspect()

		m.MinimockMakeBlizzAuthInspect()

		m.MinimockSearchItemInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBlizzAuthRoutineDone() &&
		m.MinimockGetAuctionDataDone() &&
		m.MinimockGetBlizzRealmsDone() &&
		m.MinimockGetItemMediaDone() &&
		m.MinimockGetRealmIDDone() &&
		m.MinimockMakeBlizzAuthDone() &&
		m.MinimockSearchItemDone()
}
